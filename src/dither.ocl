constant int dither_table[4][4] = {
  { 0,  8,  2,  10 },
  { 12, 4,  14, 6  },
  { 3,  11, 1,  9  },
  { 15, 7,  13, 5  },
};

int dist_sq(int3 x) {
  int3 sq = x * x;
  return sq.x + sq.y + sq.z;
}

// Ordered dithering kernel
inline uchar dither_calc(uchar3 col_in, int x, int y) {
  // calculate thresholds
  int tval = dither_table[y & 0x03][x & 0x03];
  const int thr_clo = (95 * tval) >> 4;
  const int thr_chi = (40 * tval) >> 4;
  const int thr_gs = (10 * tval) >> 4;
  
  int3 col = convert_int3(col_in);
  // find colour components
  int3 cube_crgb = (col < thr_clo)? 0 : (col - (15 + thr_chi)) / 40;
  int3 colc = (cube_crgb == 0)? (int3) 0 : (cube_crgb * 40 + 55);
  
  // find grayscale
  int avg = (col_in.x + col_in.y + col_in.z) / 3;
  int gs_idx = (avg > 238)? 23 : (avg + 2 - thr_gs) / 10;
  int3 gsc = (int3) (gs_idx * 10 + 8);
  
  // pick the closer colour
  int gs_dist = dist_sq(col - gsc);
  int col_dist = dist_sq(col - colc);
  
  // first check is necessary to increase colour resolution
  return (gs_dist < 400 && gs_dist < col_dist)? 
    (uchar) (gs_idx + 232) : 
    (uchar) (cube_crgb.x * 36 + cube_crgb.y * 6 + cube_crgb.z + 16);
}

kernel void ordered_dither(global const uchar* src, global uchar* dst) {
  size_t id = get_global_id(1) * get_global_size(0) + get_global_id(0);
  
  uchar3 src_vec = vload3(id, src);
  dst[id] = dither_calc(src_vec, get_global_id(0), get_global_id(1));
  // if (get_global_id(0) == 360)
  //   printf("%v3hhu -> %hhu\n", src[id], dst[id]);
}